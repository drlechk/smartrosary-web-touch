<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>LVGL WebBLE — Round Touch + LV_DIR D-pad</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, sans-serif; --btn: clamp(56px, 14vw, 72px); }
    body {
      margin: 0; color: #e6e9ee; background: #0b0d10;
      min-height: 100svh; display: flex; align-items: center; justify-content: center; padding: 16px;
    }
    .wrap { width: 100%; max-width: 520px; display: flex; flex-direction: column; align-items: center; gap: 14px; text-align: center; }
    h1 { margin: 0; font-size: 1.05rem; color: #cfd7e3; font-weight: 600; }

    .controls { width: 100%; display: grid; grid-template-columns: 1fr; gap: 10px; align-items: center; justify-items: center; }
    button#connect {
      width: 100%; max-width: 420px; border: 0; padding: 14px 16px; border-radius: 12px;
      background: #2979ff; color: white; font-weight: 700; font-size: 1rem; cursor: pointer;
    }
    button#connect:disabled { opacity: 0.6; cursor: default; }
    #status { opacity: 0.9; font-size: 0.95rem; }

    .canvas-shell { display: inline-block; user-select: none; border-radius: 50%; padding: 10px; background: #11161d; }
    /* Round canvas: visual + hit testing */
    canvas#lvgl_canvas {
      display: block;
      width: min(92vw, 480px); height: auto; /* CSS size; logical is 480×480 */
      background: radial-gradient(ellipse at center, #0f1319 0%, #0f1319 60%, #0c1016 100%);
      border: 4px solid #03a9f4;
      border-radius: 50%;
      clip-path: circle(50% at 50% 50%);
      outline: none;
      touch-action: none;
      cursor: crosshair;
    }
    #coords { font-size: 0.95rem; opacity: 0.9; }
    .banner { display: none; width: 100%; max-width: 480px; background: #ff9800; color: #0b0d10; padding: 10px 12px; border-radius: 10px; font-size: 0.95rem; }

    /* D-pad cross */
    .dpad {
      display: grid;
      grid-template-columns: var(--btn) var(--btn) var(--btn);
      grid-template-rows: var(--btn) var(--btn) var(--btn);
      gap: 12px; margin-top: 6px; justify-items: center; align-items: center;
    }
    .dpad button {
      width: var(--btn); height: var(--btn);
      border-radius: 16px; border: 0; background: #1a232e; color: #e6e9ee;
      font-size: calc(var(--btn) * 0.35); font-weight: 700; cursor: pointer;
      box-shadow: 0 2px 8px rgba(0,0,0,0.35);
      touch-action: manipulation;
    }
    .dpad .empty { width: var(--btn); height: var(--btn); visibility: hidden; }
    .dpad button:disabled { opacity: 0.5; cursor: default; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>LVGL WebBLE — Round Touch + LV_DIR D-pad</h1>

    <div class="controls">
      <button id="connect" aria-label="Connect to BLE">Connect</button>
      <span id="status">Not connected</span>
    </div>

    <div class="canvas-shell">
      <canvas id="lvgl_canvas" width="480" height="480" aria-label="Round touch surface"></canvas>
    </div>

    <div id="coords">x: –, y: –, pressed: –</div>
    <div id="banner" class="banner"></div>

    <!-- D-pad cross sending LV_DIR byte -->
    <div class="dpad" role="group" aria-label="LVGL directions" >
      <div class="empty"></div>
      <button id="btnUp"    aria-label="Top (LV_DIR_TOP)">▲</button>
      <div class="empty"></div>

      <button id="btnLeft"  aria-label="Left (LV_DIR_LEFT)">◀</button>
      <div class="empty"></div>
      <button id="btnRight" aria-label="Right (LV_DIR_RIGHT)">▶</button>

      <div class="empty"></div>
      <button id="btnDown"  aria-label="Bottom (LV_DIR_BOTTOM)">▼</button>
      <div class="empty"></div>
    </div>
  </div>

  <script>
    // ==== UUIDs (set to match your ESP32) ====
    const TOUCH_SERVICE_UUID = '12345678-1234-5678-1234-56789abcdef0';
    const TOUCH_CHAR_UUID    = '12345678-1234-5678-1234-56789abcdea1'; // 5-byte pointer [xHi,xLo,yHi,yLo,state]
    const KEYS_CHAR_UUID     = '12345678-1234-5678-1234-56789abcdea2'; // 1-byte LV_DIR_*

    // LVGL direction constants (v8): LEFT=1, RIGHT=2, TOP=4, BOTTOM=8
    const LV = { LEFT:2, RIGHT:1, TOP:8, BOTTOM:4 };

    let touchChar = null, keysChar = null;
    let isDown = false;

    const connectBtn = document.getElementById('connect');
    const statusEl   = document.getElementById('status');
    const coordsEl   = document.getElementById('coords');
    const canvas     = document.getElementById('lvgl_canvas');
    const bannerEl   = document.getElementById('banner');

    const btnUp = document.getElementById('btnUp');
    const btnDown = document.getElementById('btnDown');
    const btnLeft = document.getElementById('btnLeft');
    const btnRight = document.getElementById('btnRight');

    function setDpadEnabled(enabled){
      [btnUp, btnDown, btnLeft, btnRight].forEach(b => b.disabled = !enabled);
    }
    setDpadEnabled(false);

    // Feature detection hint
    (function supportCheck(){
      const isWebBT = ('bluetooth' in navigator);
      if (!isWebBT) {
        bannerEl.style.display = 'block';
        bannerEl.textContent = 'Web Bluetooth is not supported in this browser.';
      }
    })();

    // Map pointer to canvas pixels (handles CSS scaling / HiDPI)
    function canvasXY(e) {
      const r  = canvas.getBoundingClientRect();
      const sx = canvas.width  / r.width;
      const sy = canvas.height / r.height;
      const x  = Math.round((e.clientX - r.left) * sx);
      const y  = Math.round((e.clientY - r.top)  * sy);
      return { x, y };
    }

    // Clamp point to circle (centered circle with radius = min(w,h)/2)
    function clampToCircle(x, y) {
      const W = canvas.width, H = canvas.height;
      const cx = W / 2, cy = H / 2;
      const dx = x - cx, dy = y - cy;
      const r  = Math.min(W, H) / 2;
      const d2 = dx*dx + dy*dy;
      if (d2 <= r*r) return { x: Math.round(x), y: Math.round(y) };
      const d = Math.sqrt(d2) || 1;
      const k = r / d;
      return { x: Math.round(cx + dx * k), y: Math.round(cy + dy * k) };
    }

    async function connectBLE() {
      if (!('bluetooth' in navigator)) {
        statusEl.textContent = 'Web Bluetooth not supported.';
        return;
      }
      connectBtn.disabled = true;
      statusEl.textContent = 'Requesting device…';
      try {
        const device = await navigator.bluetooth.requestDevice({
          filters: [{ services: [TOUCH_SERVICE_UUID] }]
        });
        device.addEventListener('gattserverdisconnected', () => {
          statusEl.textContent = 'Disconnected';
          touchChar = null; keysChar = null;
          connectBtn.disabled = false;
          setDpadEnabled(false);
        });

        statusEl.textContent = 'Connecting…';
        const gatt = await device.gatt.connect();

        statusEl.textContent = 'Getting service…';
        const svc = await gatt.getPrimaryService(TOUCH_SERVICE_UUID);

        statusEl.textContent = 'Getting characteristics…';
        touchChar = await svc.getCharacteristic(TOUCH_CHAR_UUID);

        try {
          keysChar = await svc.getCharacteristic(KEYS_CHAR_UUID);
          setDpadEnabled(true);
        } catch (e) {
          console.warn('Keys characteristic not found:', e);
          setDpadEnabled(false);
        }

        statusEl.textContent = keysChar ? 'BLE ready (touch + LV_DIR keys)' : 'BLE ready (touch only)';
      } catch (err) {
        console.error(err);
        statusEl.textContent = 'Error: ' + (err?.message || err);
        connectBtn.disabled = false;
      }
    }
    connectBtn.addEventListener('click', connectBLE);

    // ----- Touch sender: [X_hi, X_lo, Y_hi, Y_lo, State] -----
    function sendTouch(x, y, down) {
      coordsEl.textContent = `x: ${x}, y: ${y}, pressed: ${down ? 'yes' : 'no'}`;
      if (!touchChar) return;
      const buf = new ArrayBuffer(5);
      const v   = new DataView(buf);
      v.setUint16(0, x, false);   // big-endian
      v.setUint16(2, y, false);   // big-endian
      v.setUint8 (4, down ? 1 : 0);
      touchChar.writeValueWithoutResponse(buf).catch(async () => {
        try { await touchChar.writeValue(buf); } catch(_) {}
      });
    }

    // ----- LV_DIR sender: 1 byte -----
    function sendDir(dirByte) {
      if (!keysChar) return;
      const buf = new Uint8Array([dirByte & 0xFF]);
      keysChar.writeValueWithoutResponse(buf).catch(async () => {
        try { await keysChar.writeValue(buf); } catch(_) {}
      });
    }

    // Round-canvas pointer events
    canvas.addEventListener('pointermove', (e) => {
      const {x, y} = canvasXY(e);
      const p = clampToCircle(x, y);
      const down = e.pointerType === 'mouse' ? !!e.buttons : isDown;
      sendTouch(p.x, p.y, down);
      e.preventDefault();
    }, { passive: false });

    canvas.addEventListener('pointerdown', (e) => {
      isDown = true; canvas.setPointerCapture(e.pointerId);
      const {x, y} = canvasXY(e);
      const p = clampToCircle(x, y);
      sendTouch(p.x, p.y, true);
      e.preventDefault();
    }, { passive: false });

    function endPointer(e) {
      isDown = false;
      const {x, y} = canvasXY(e);
      const p = clampToCircle(x, y);
      sendTouch(p.x, p.y, false);
      e.preventDefault();
    }
    canvas.addEventListener('pointerup', endPointer, { passive: false });
    canvas.addEventListener('pointercancel', endPointer, { passive: false });
    canvas.addEventListener('pointerleave', endPointer, { passive: false });
    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    // D-pad buttons (send LV_DIR byte)
    btnUp   .addEventListener('pointerdown', e => { sendDir(LV.TOP);    e.preventDefault(); });
    btnDown .addEventListener('pointerdown', e => { sendDir(LV.BOTTOM); e.preventDefault(); });
    btnLeft .addEventListener('pointerdown', e => { sendDir(LV.LEFT);   e.preventDefault(); });
    btnRight.addEventListener('pointerdown', e => { sendDir(LV.RIGHT);  e.preventDefault(); });

    // Optional keyboard on desktop
    window.addEventListener('keydown', (e) => {
      if (e.repeat) return;
      if (e.key === 'ArrowUp')    { sendDir(LV.TOP);    e.preventDefault(); }
      if (e.key === 'ArrowDown')  { sendDir(LV.BOTTOM); e.preventDefault(); }
      if (e.key === 'ArrowLeft')  { sendDir(LV.LEFT);   e.preventDefault(); }
      if (e.key === 'ArrowRight') { sendDir(LV.RIGHT);  e.preventDefault(); }
    });
  </script>
</body>
</html>